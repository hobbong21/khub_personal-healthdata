name: CD Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_BACKEND: ${{ github.repository }}/backend
  IMAGE_NAME_FRONTEND: ${{ github.repository }}/frontend

jobs:
  # ë°°í¬ ì¡°ê±´ í™•ì¸
  check-deployment:
    name: Check Deployment Conditions
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      environment: ${{ steps.check.outputs.environment }}
      
    steps:
    - name: Check deployment conditions
      id: check
      run: |
        if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "environment=staging" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "environment=production" >> $GITHUB_OUTPUT
        elif [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          echo "environment=staging" >> $GITHUB_OUTPUT
        else
          echo "should-deploy=false" >> $GITHUB_OUTPUT
        fi

  # Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: check-deployment
    if: needs.check-deployment.outputs.should-deploy == 'true'
    
    permissions:
      contents: read
      packages: write
      
    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
      backend-digest: ${{ steps.build-backend.outputs.digest }}
      frontend-digest: ${{ steps.build-frontend.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    # ë°±ì—”ë“œ ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„°
    - name: Extract backend metadata
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    # í”„ë¡ íŠ¸ì—”ë“œ ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„°
    - name: Extract frontend metadata
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    # ë°±ì—”ë“œ ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ
    - name: Build and push backend image
      id: build-backend
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64
        
    # í”„ë¡ íŠ¸ì—”ë“œ ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ
    - name: Build and push frontend image
      id: build-frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

  # ë³´ì•ˆ ìŠ¤ìº”
  security-scan-images:
    name: Security Scan Images
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Run Trivy vulnerability scanner on backend
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-push.outputs.backend-image }}
        format: 'sarif'
        output: 'backend-trivy-results.sarif'
        
    - name: Run Trivy vulnerability scanner on frontend
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ needs.build-and-push.outputs.frontend-image }}
        format: 'sarif'
        output: 'frontend-trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'backend-trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'frontend-trivy-results.sarif'

  # ìŠ¤í…Œì´ì§• ë°°í¬
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, security-scan-images]
    if: needs.check-deployment.outputs.environment == 'staging'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME_STAGING }}
        
    - name: Deploy to staging
      run: |
        # Helm ë°°í¬
        helm upgrade --install khub-staging ./helm/khub \
          --namespace staging \
          --create-namespace \
          --set image.backend.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }} \
          --set image.backend.tag=${{ github.sha }} \
          --set image.frontend.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }} \
          --set image.frontend.tag=${{ github.sha }} \
          --set environment=staging \
          --values ./helm/khub/values-staging.yaml
          
    - name: Wait for deployment
      run: |
        kubectl rollout status deployment/khub-backend -n staging --timeout=300s
        kubectl rollout status deployment/khub-frontend -n staging --timeout=300s
        
    - name: Run smoke tests
      run: |
        # ìŠ¤í…Œì´ì§• í™˜ê²½ smoke test
        curl -f ${{ secrets.STAGING_URL }}/api/health
        curl -f ${{ secrets.STAGING_URL }}/
        
    - name: Notify deployment success
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'ðŸš€ Successfully deployed to staging: ${{ secrets.STAGING_URL }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # í”„ë¡œë•ì…˜ ë°°í¬ ìŠ¹ì¸ ëŒ€ê¸°
  await-production-approval:
    name: Await Production Approval
    runs-on: ubuntu-latest
    needs: [check-deployment, deploy-staging]
    if: needs.check-deployment.outputs.environment == 'production' || (needs.deploy-staging.result == 'success' && github.ref == 'refs/heads/main')
    environment: production-approval
    
    steps:
    - name: Request production deployment approval
      run: |
        echo "Production deployment requires manual approval"
        echo "Staging URL: ${{ secrets.STAGING_URL }}"
        echo "Backend Image: ${{ needs.build-and-push.outputs.backend-image }}"
        echo "Frontend Image: ${{ needs.build-and-push.outputs.frontend-image }}"

  # í”„ë¡œë•ì…˜ ë°°í¬
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [check-deployment, build-and-push, security-scan-images, await-production-approval]
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME_PRODUCTION }}
        
    - name: Create database backup
      run: |
        # í”„ë¡œë•ì…˜ DB ë°±ì—…
        kubectl create job --from=cronjob/postgres-backup backup-$(date +%Y%m%d-%H%M%S) -n production
        
    - name: Deploy to production with blue-green strategy
      run: |
        # Blue-Green ë°°í¬
        helm upgrade --install khub-production ./helm/khub \
          --namespace production \
          --create-namespace \
          --set image.backend.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_BACKEND }} \
          --set image.backend.tag=${{ github.sha }} \
          --set image.frontend.repository=${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONTEND }} \
          --set image.frontend.tag=${{ github.sha }} \
          --set environment=production \
          --set deployment.strategy=blue-green \
          --values ./helm/khub/values-production.yaml
          
    - name: Wait for deployment
      run: |
        kubectl rollout status deployment/khub-backend -n production --timeout=600s
        kubectl rollout status deployment/khub-frontend -n production --timeout=600s
        
    - name: Run production health checks
      run: |
        # í”„ë¡œë•ì…˜ health check
        for i in {1..10}; do
          if curl -f ${{ secrets.PRODUCTION_URL }}/api/health; then
            echo "Health check passed"
            break
          fi
          echo "Health check failed, retrying in 30s..."
          sleep 30
        done
        
        # ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
        curl -f ${{ secrets.PRODUCTION_URL }}/
        
    - name: Update DNS (if needed)
      run: |
        # Route53 DNS ì—…ë°ì´íŠ¸ (í•„ìš”ì‹œ)
        echo "DNS update completed"
        
    - name: Notify production deployment
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: 'ðŸŽ‰ Successfully deployed to production: ${{ secrets.PRODUCTION_URL }}'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ë°°í¬ í›„ ëª¨ë‹ˆí„°ë§
  post-deployment-monitoring:
    name: Post-Deployment Monitoring
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'
    
    steps:
    - name: Monitor application metrics
      run: |
        # 5ë¶„ê°„ ë©”íŠ¸ë¦­ ëª¨ë‹ˆí„°ë§
        sleep 300
        
        # Prometheus ë©”íŠ¸ë¦­ í™•ì¸
        curl -s "${{ secrets.PROMETHEUS_URL }}/api/v1/query?query=up{job=\"khub-backend\"}" | jq '.data.result[0].value[1]'
        curl -s "${{ secrets.PROMETHEUS_URL }}/api/v1/query?query=up{job=\"khub-frontend\"}" | jq '.data.result[0].value[1]'
        
    - name: Check error rates
      run: |
        # ì—ëŸ¬ìœ¨ í™•ì¸
        ERROR_RATE=$(curl -s "${{ secrets.PROMETHEUS_URL }}/api/v1/query?query=rate(http_requests_total{status=~\"5..\"}[5m])" | jq -r '.data.result[0].value[1] // "0"')
        
        if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
          echo "High error rate detected: $ERROR_RATE"
          exit 1
        fi
        
    - name: Rollback on failure
      if: failure()
      run: |
        echo "Rolling back due to monitoring failure"
        helm rollback khub-production -n production
        
        # ë¡¤ë°± ì•Œë¦¼
        curl -X POST -H 'Content-type: application/json' \
          --data '{"text":"ðŸš¨ Production rollback initiated due to monitoring failure"}' \
          ${{ secrets.SLACK_WEBHOOK_URL }}

  # ë¦´ë¦¬ì¦ˆ ë…¸íŠ¸ ìƒì„±
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Generate changelog
      id: changelog
      run: |
        # ì´ì „ íƒœê·¸ë¶€í„° í˜„ìž¬ê¹Œì§€ì˜ ë³€ê²½ì‚¬í•­ ìƒì„±
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        if [ -n "$PREVIOUS_TAG" ]; then
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD)
        else
          CHANGELOG=$(git log --pretty=format:"- %s (%h)" HEAD)
        fi
        
        echo "changelog<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Create GitHub Release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref_name }}
        release_name: Release ${{ github.ref_name }}
        body: |
          ## Changes in this release
          
          ${{ steps.changelog.outputs.changelog }}
          
          ## Docker Images
          
          - Backend: `${{ needs.build-and-push.outputs.backend-image }}`
          - Frontend: `${{ needs.build-and-push.outputs.frontend-image }}`
          
          ## Deployment
          
          - Production URL: ${{ secrets.PRODUCTION_URL }}
          - Deployed at: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        draft: false
        prerelease: false