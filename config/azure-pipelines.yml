# Azure DevOps Pipeline for K-hub

trigger:
  branches:
    include:
      - main
      - develop
  tags:
    include:
      - v*

pr:
  branches:
    include:
      - main
      - develop

variables:
  - group: khub-variables
  - name: nodeVersion
    value: '18'
  - name: dockerRegistryServiceConnection
    value: 'docker-registry-connection'
  - name: imageRepository
    value: 'khub'
  - name: containerRegistry
    value: 'your-registry.azurecr.io'
  - name: dockerfilePath
    value: '$(Build.SourcesDirectory)/Dockerfile'
  - name: tag
    value: '$(Build.BuildId)'
  - name: vmImageName
    value: 'ubuntu-latest'

stages:
- stage: Validate
  displayName: 'Code Quality & Security'
  jobs:
  - job: Lint
    displayName: 'Lint and Format Check'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cd backend
        npm ci
        npm run lint
        npm run format:check
      displayName: 'Backend Lint'
    
    - script: |
        cd frontend
        npm ci
        npm run lint
        npm run format:check
      displayName: 'Frontend Lint'

  - job: SecurityAudit
    displayName: 'Security Audit'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cd backend
        npm ci
        npm audit --audit-level=high
      displayName: 'Backend Security Audit'
      continueOnError: true
    
    - script: |
        cd frontend
        npm ci
        npm audit --audit-level=high
      displayName: 'Frontend Security Audit'
      continueOnError: true

- stage: Test
  displayName: 'Run Tests'
  dependsOn: Validate
  jobs:
  - job: BackendTests
    displayName: 'Backend Tests'
    pool:
      vmImage: $(vmImageName)
    services:
      postgres: postgres:15
      redis: redis:7
    variables:
      DATABASE_URL: 'postgresql://postgres:postgres@localhost:5432/khub_test'
      REDIS_URL: 'redis://localhost:6379'
      JWT_SECRET: 'test-jwt-secret'
      NODE_ENV: 'test'
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cd backend
        npm ci
        npx prisma generate
        npx prisma migrate deploy
        npm run test
        npm run test:coverage
      displayName: 'Run Backend Tests'
    
    - task: PublishTestResults@2
      condition: succeededOrFailed()
      inputs:
        testRunner: JUnit
        testResultsFiles: 'backend/test-results.xml'
        testRunTitle: 'Backend Tests'
    
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: 'backend/coverage/cobertura-coverage.xml'
        reportDirectory: 'backend/coverage'

  - job: FrontendTests
    displayName: 'Frontend Tests'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cd frontend
        npm ci
        npm run test
        npm run test:coverage
      displayName: 'Run Frontend Tests'
    
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: 'frontend/coverage/cobertura-coverage.xml'
        reportDirectory: 'frontend/coverage'

  - job: E2ETests
    displayName: 'E2E Tests'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: NodeTool@0
      inputs:
        versionSpec: $(nodeVersion)
      displayName: 'Install Node.js'
    
    - script: |
        cp .env.example .env
        sed -i 's/your-secure-postgres-password/test_password/g' .env
        docker-compose -f config/docker-compose.dev.yml up -d
        sleep 30
      displayName: 'Start Test Environment'
    
    - script: |
        timeout 60 bash -c 'until curl -f http://localhost:3001/api/health; do sleep 2; done'
        timeout 60 bash -c 'until curl -f http://localhost:5173; do sleep 2; done'
      displayName: 'Wait for Services'
    
    - script: |
        cd e2e-tests
        npm ci
        npx playwright install
        npm run test
      displayName: 'Run E2E Tests'
    
    - script: |
        docker-compose -f config/docker-compose.dev.yml down
      displayName: 'Cleanup Test Environment'
      condition: always()
    
    - task: PublishTestResults@2
      condition: succeededOrFailed()
      inputs:
        testRunner: JUnit
        testResultsFiles: 'e2e-tests/test-results.xml'
        testRunTitle: 'E2E Tests'

- stage: Build
  displayName: 'Build and Push Images'
  dependsOn: Test
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), eq(variables['Build.SourceBranch'], 'refs/heads/develop'), startsWith(variables['Build.SourceBranch'], 'refs/tags/v')))
  jobs:
  - job: BuildBackend
    displayName: 'Build Backend Image'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: 'Build Backend Image'
      inputs:
        command: 'buildAndPush'
        repository: '$(imageRepository)/backend'
        dockerfile: 'backend/Dockerfile'
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest

  - job: BuildFrontend
    displayName: 'Build Frontend Image'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: 'Build Frontend Image'
      inputs:
        command: 'buildAndPush'
        repository: '$(imageRepository)/frontend'
        dockerfile: 'frontend/Dockerfile'
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          latest

- stage: SecurityScan
  displayName: 'Container Security Scan'
  dependsOn: Build
  jobs:
  - job: ScanImages
    displayName: 'Scan Container Images'
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: AzureContainerRegistry@0
      displayName: 'Login to ACR'
      inputs:
        azureSubscription: $(azureServiceConnection)
        azureContainerRegistry: $(containerRegistry)
    
    - script: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
          $(containerRegistry)/$(imageRepository)/backend:$(tag)
      displayName: 'Scan Backend Image'
    
    - script: |
        docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
          aquasec/trivy image --exit-code 1 --severity HIGH,CRITICAL \
          $(containerRegistry)/$(imageRepository)/frontend:$(tag)
      displayName: 'Scan Frontend Image'

- stage: DeployStaging
  displayName: 'Deploy to Staging'
  dependsOn: SecurityScan
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  jobs:
  - deployment: DeployToStaging
    displayName: 'Deploy to Staging Environment'
    pool:
      vmImage: $(vmImageName)
    environment: 'staging'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: KubernetesManifest@0
            displayName: 'Deploy to Staging'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'k8s-staging-connection'
              namespace: 'khub-staging'
              manifests: |
                k8s/staging/*.yaml
              containers: |
                $(containerRegistry)/$(imageRepository)/backend:$(tag)
                $(containerRegistry)/$(imageRepository)/frontend:$(tag)
          
          - script: |
              kubectl rollout status deployment/khub-backend -n khub-staging --timeout=300s
              kubectl rollout status deployment/khub-frontend -n khub-staging --timeout=300s
              curl -f https://staging.khub.example.com/api/health
            displayName: 'Verify Staging Deployment'

- stage: PerformanceTest
  displayName: 'Performance Testing'
  dependsOn: DeployStaging
  jobs:
  - job: LoadTest
    displayName: 'Load Testing'
    pool:
      vmImage: $(vmImageName)
    steps:
    - script: |
        docker run --rm -v $(pwd)/performance-tests:/scripts \
          grafana/k6:latest run --out json=/scripts/performance-results.json /scripts/load-test.js
      displayName: 'Run Load Tests'
      env:
        BASE_URL: 'https://staging.khub.example.com'
    
    - task: PublishTestResults@2
      inputs:
        testRunner: 'JUnit'
        testResultsFiles: 'performance-tests/performance-results.json'
        testRunTitle: 'Performance Tests'

- stage: DeployProduction
  displayName: 'Deploy to Production'
  dependsOn: PerformanceTest
  condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/tags/v')))
  jobs:
  - deployment: DeployToProduction
    displayName: 'Deploy to Production Environment'
    pool:
      vmImage: $(vmImageName)
    environment: 'production'
    strategy:
      runOnce:
        deploy:
          steps:
          - script: |
              kubectl create job --from=cronjob/postgres-backup \
                backup-$(date +%Y%m%d-%H%M%S) -n khub-production
            displayName: 'Backup Database'
          
          - task: KubernetesManifest@0
            displayName: 'Deploy to Production'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: 'k8s-production-connection'
              namespace: 'khub-production'
              manifests: |
                k8s/production/*.yaml
              containers: |
                $(containerRegistry)/$(imageRepository)/backend:$(tag)
                $(containerRegistry)/$(imageRepository)/frontend:$(tag)
          
          - script: |
              kubectl rollout status deployment/khub-backend -n khub-production --timeout=600s
              kubectl rollout status deployment/khub-frontend -n khub-production --timeout=600s
              
              for i in {1..10}; do
                if curl -f https://khub.example.com/api/health; then
                  echo "Health check passed"
                  break
                fi
                echo "Health check failed, retrying in 30s..."
                sleep 30
              done
            displayName: 'Verify Production Deployment'

- stage: PostDeploymentMonitoring
  displayName: 'Post-Deployment Monitoring'
  dependsOn: DeployProduction
  jobs:
  - job: MonitorProduction
    displayName: 'Monitor Production Metrics'
    pool:
      vmImage: $(vmImageName)
    steps:
    - script: |
        sleep 300  # 5분 대기
        
        ERROR_RATE=$(curl -s "$(PROMETHEUS_URL)/api/v1/query?query=rate(http_requests_total{status=~\"5..\"}[5m])" | \
                    jq -r '.data.result[0].value[1] // "0"')
        
        if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
          echo "High error rate detected: $ERROR_RATE"
          exit 1
        fi
      displayName: 'Monitor Error Rates'
    
    - script: |
        if [ $? -ne 0 ]; then
          echo "Rolling back due to monitoring failure"
          kubectl rollout undo deployment/khub-backend -n khub-production
          kubectl rollout undo deployment/khub-frontend -n khub-production
        fi
      displayName: 'Rollback on Failure'
      condition: failed()

- stage: Notify
  displayName: 'Notifications'
  dependsOn: 
    - DeployProduction
    - PostDeploymentMonitoring
  condition: always()
  jobs:
  - job: SendNotifications
    displayName: 'Send Notifications'
    pool:
      vmImage: $(vmImageName)
    steps:
    - script: |
        if [ "$(Agent.JobStatus)" = "Succeeded" ]; then
          MESSAGE="✅ K-hub deployment successful! Version: $(tag), Environment: Production"
        else
          MESSAGE="❌ K-hub deployment failed! Build: $(Build.BuildNumber), Branch: $(Build.SourceBranchName)"
        fi
        
        curl -X POST -H 'Content-type: application/json' \
          --data "{\"text\":\"$MESSAGE\"}" \
          $(SLACK_WEBHOOK_URL)
      displayName: 'Send Slack Notification'
